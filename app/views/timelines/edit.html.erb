<div x-data="timelineEditor()" class="min-h-screen flex flex-col bg-gray-50 dark:bg-gray-900">

  <%# Header Partial %>
  <%= render 'timelines/edit/header', timeline: @timeline %>

  <!-- Three-Column Layout with Pull-Out Tabs -->
  <div class="flex-1 flex min-h-0 relative">

    <%# Left Sidebar (Desktop - beside content) %>
    <div x-show="showLeftSidebar && isDesktop" x-cloak
         x-transition:enter="transform transition ease-in-out duration-200"
         x-transition:enter-start="-translate-x-full"
         x-transition:enter-end="translate-x-0"
         x-transition:leave="transform transition ease-in-out duration-200"
         x-transition:leave-end="-translate-x-full"
         class="hidden lg:block flex-shrink-0">
      <%= render 'timelines/edit/left_sidebar',
          timeline: @timeline,
          timeline_event_tags: @timeline_event_tags,
          timeline_content_summary: @timeline_content_summary %>
    </div>

    <%# Mobile/Tablet Left Sidebar Overlay %>
    <div x-show="showLeftSidebar && !isDesktop" x-cloak
         x-transition:enter="transition-opacity ease-linear duration-200"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition-opacity ease-linear duration-200"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         @click="showLeftSidebar = false"
         class="lg:hidden fixed inset-0 bg-black bg-opacity-50 z-40"
         role="presentation"
         aria-hidden="true">
    </div>

    <%# Mobile/Tablet Left Sidebar Panel %>
    <div x-show="showLeftSidebar && !isDesktop" x-cloak
         x-transition:enter="transform transition ease-in-out duration-200"
         x-transition:enter-start="-translate-x-full"
         x-transition:enter-end="translate-x-0"
         x-transition:leave="transform transition ease-in-out duration-200"
         x-transition:leave-end="-translate-x-full"
         class="lg:hidden fixed left-0 top-0 h-full w-80 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 shadow-xl z-50 overflow-y-auto">

      <%# Mobile close button %>
      <div class="p-3 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 lg:hidden">
        <button @click="showLeftSidebar = false"
                class="flex items-center hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors p-1.5 -ml-1.5 focus:outline-none focus:ring-2 focus:ring-blue-500"
                aria-label="Close Timeline Tools">
          <i class="material-icons text-gray-500 text-lg mr-1">chevron_left</i>
          <i class="material-icons text-gray-600 text-lg mr-1.5">menu</i>
          <h2 class="text-sm font-semibold text-gray-900 dark:text-white">Timeline Tools</h2>
        </button>
      </div>

      <%= render 'timelines/edit/left_sidebar_content',
          timeline: @timeline,
          timeline_event_tags: @timeline_event_tags,
          timeline_content_summary: @timeline_content_summary %>
    </div>

    <%# Desktop Left Sidebar Toggle Tab (when collapsed) %>
    <div x-show="!showLeftSidebar && isDesktop" x-cloak
         class="hidden lg:block fixed top-28 z-30 transition-all duration-300">
      <button @click="toggleLeftSidebar()"
              class="bg-notebook-blue hover:bg-blue-600 text-white p-2 rounded-r-md shadow-lg transition-all duration-300 flex items-center gap-1 tooltip-right"
              data-tooltip="Show Timeline Tools"
              aria-label="Show Timeline Tools">
        <i class="material-icons text-base">menu</i>
        <i class="material-icons text-base">chevron_right</i>
      </button>
    </div>

    <%# Mobile/Tablet Left Sidebar Toggle Tab %>
    <div class="lg:hidden fixed top-28 z-30 transition-all duration-300">
      <button @click="toggleLeftSidebar()"
              @keydown.escape="showLeftSidebar && toggleLeftSidebar()"
              class="bg-notebook-blue hover:bg-blue-600 text-white p-2 rounded-r-md shadow-lg transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-blue-500 flex items-center gap-1"
              :title="showLeftSidebar ? 'Close Timeline Tools' : 'Open Timeline Tools'"
              :aria-label="showLeftSidebar ? 'Close Timeline Tools' : 'Open Timeline Tools'"
              :aria-expanded="showLeftSidebar">
        <i class="material-icons text-base" x-show="!showLeftSidebar">menu</i>
        <i class="material-icons text-base" x-show="!showLeftSidebar">chevron_right</i>
        <i class="material-icons text-base" x-show="showLeftSidebar">chevron_left</i>
      </button>
    </div>

    <!-- Main Content Area -->
    <main class="flex-1 overflow-y-auto min-h-0">
      <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        <div class="timeline-events-container relative" data-timeline-id="<%= @timeline.id %>">
          <!-- Timeline Rail - Extended to Header -->
          <div class="absolute top-0 bottom-0 w-0.5 bg-gray-300 dark:bg-gray-700 timeline-spine rounded-full"></div>

          <%# Timeline Overview Partial %>
          <%= render 'timelines/edit/timeline_overview', timeline: @timeline %>

          <!-- Timeline Events -->
          <% if @timeline.timeline_events.any? %>
            <% @timeline.timeline_events.includes(:timeline_event_entities).each_with_index do |event, index| %>
              <%= render 'timeline_events/event_card', event: event, timeline: @timeline, index: index %>
            <% end %>
          <% else %>
            <!-- Empty State -->
            <div class="text-center py-16">
              <div class="mx-auto h-24 w-24 rounded-full bg-gradient-to-br from-green-100 to-green-200 flex items-center justify-center mb-6 shadow-sm">
                <i class="material-icons text-4xl text-green-600">timeline</i>
              </div>
              <h3 class="text-xl font-semibold text-gray-900 mb-3">Your timeline is empty</h3>
              <p class="text-gray-600 mb-8 max-w-md mx-auto">
                Start building your timeline by adding your first event. Track important moments, plot points, and key developments in chronological order.
              </p>
              <button id="js-create-first-event"
                      class="inline-flex items-center px-6 py-3 text-base font-medium rounded-lg text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 shadow-sm transition-colors">
                <i class="material-icons text-lg mr-2">add</i>
                Add Your First Event
              </button>
            </div>
          <% end %>
        </div>
      </div>
    </main>

    <%# Right Inspector Panel (Desktop - beside content) %>
    <div x-show="showRightSidebar && isDesktop" x-cloak
         x-transition:enter="transform transition ease-in-out duration-200"
         x-transition:enter-start="translate-x-full"
         x-transition:enter-end="translate-x-0"
         x-transition:leave="transform transition ease-in-out duration-200"
         x-transition:leave-start="translate-x-0"
         x-transition:leave-end="translate-x-full"
         class="hidden lg:block flex-shrink-0">
      <%= render 'timelines/edit/inspector_panel', timeline: @timeline %>
    </div>

    <%# Desktop Right Sidebar Toggle Tab (when collapsed) %>
    <div x-show="!showRightSidebar && isDesktop" x-cloak
         class="hidden lg:block fixed right-0 top-28 z-40">
      <button @click="toggleRightSidebar()"
              class="bg-notebook-blue hover:bg-blue-600 text-white p-2 rounded-l-md shadow-lg transition-all duration-300 flex items-center gap-1 tooltip-left"
              data-tooltip="Show Event Details"
              aria-label="Show Event Details">
        <i class="material-icons text-base">chevron_left</i>
        <i class="material-icons text-base">info</i>
      </button>
    </div>

    <%# Mobile/Tablet Right Sidebar Toggle Tab %>
    <div class="lg:hidden fixed right-0 top-28 z-40">
      <button @click="toggleRightSidebar()"
              @keydown.escape="showRightSidebar && toggleRightSidebar()"
              class="bg-notebook-blue hover:bg-blue-600 text-white p-2 rounded-l-md shadow-lg transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-blue-500 flex items-center gap-1"
              :title="showRightSidebar ? 'Close Event Details' : 'Open Event Details'"
              :aria-label="showRightSidebar ? 'Close Event Details' : 'Open Event Details'"
              :aria-expanded="showRightSidebar">
        <i class="material-icons text-base" x-show="!showRightSidebar">chevron_left</i>
        <i class="material-icons text-base" x-show="!showRightSidebar">info</i>
        <i class="material-icons text-base" x-show="showRightSidebar">chevron_right</i>
      </button>
    </div>

    <%# Mobile/Tablet Right Sidebar Overlay %>
    <div x-show="showRightSidebar && !isDesktop" x-cloak
         x-transition:enter="transition-opacity ease-linear duration-200"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition-opacity ease-linear duration-200"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         @click="closeMobileSidebar()"
         @keydown.escape.window="closeMobileSidebar()"
         class="lg:hidden fixed inset-0 bg-black bg-opacity-50 z-50"
         role="presentation"
         aria-hidden="true">
    </div>

    <%# Mobile/Tablet Right Sidebar Panel %>
    <div x-show="showRightSidebar && !isDesktop" x-cloak
         x-transition:enter="transform transition ease-in-out duration-200"
         x-transition:enter-start="translate-x-full"
         x-transition:enter-end="translate-x-0"
         x-transition:leave="transform transition ease-in-out duration-200"
         x-transition:leave-start="translate-x-0"
         x-transition:leave-end="translate-x-full"
         @keydown.escape="closeMobileSidebar()"
         class="lg:hidden fixed right-0 top-0 h-full w-96 bg-white dark:bg-gray-800 border-l border-gray-200 dark:border-gray-700 shadow-xl z-50 overflow-y-auto"
         role="dialog"
         aria-modal="true"
         aria-labelledby="mobile-inspector-title">

      <%# Mobile close button %>
      <div class="p-3 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800">
        <button @click="closeMobileSidebar()"
                class="flex items-center hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors p-1.5 -ml-1.5 focus:outline-none focus:ring-2 focus:ring-blue-500"
                aria-label="Close Event Details">
          <i class="material-icons text-gray-500 text-lg mr-1">chevron_right</i>
          <i class="material-icons text-gray-600 text-lg mr-1.5">info</i>
          <h2 id="mobile-inspector-title" class="text-sm font-semibold text-gray-900 dark:text-white">Event Details</h2>
        </button>
      </div>

      <%= render 'timelines/edit/inspector_panel_content', timeline: @timeline %>
    </div>
  </div>

  <%# Settings Modal Partial %>
  <%= render 'timelines/edit/settings_modal', timeline: @timeline %>

  <%# Link Content Modal Partial %>
  <%= render 'timelines/edit/link_content_modal',
      timeline: @timeline,
      timeline_linked_content: @timeline_linked_content,
      current_user_content: @current_user_content %>

  <%# Share Modal Partial %>
  <%= render 'timelines/edit/share_modal', timeline: @timeline %>
</div>

<!-- Timeline Editor Initialization Data (for external JS files) -->
<script type="application/json" id="timeline-editor-init-data">
  <%= {
    timeline: {
      id: @timeline.id,
      name: @timeline.name,
      subtitle: @timeline.subtitle,
      is_archived: @timeline.archived?
    },
    tags: @timeline.page_tags.map(&:tag),
    timeline_event_tags: @timeline_event_tags.map { |t| t[:name] },
    event_types: TimelineEvent::EVENT_TYPES.transform_values { |v| { icon: v[:icon], name: v[:name] } }
  }.to_json.html_safe %>
</script>

<!-- JavaScript for Timeline Editor -->
<!-- External files available: timeline_editor_component.js, timeline_form_helpers.js -->
<script>
// Create a direct Alpine.js component using object literal syntax
function timelineEditor() {
  return {
    showMetaPanel: false,
    showLinkModal: false,
    showShareModal: false,
    showFilters: false,
    showMobileFilters: false,
    linkingEventId: null,
    draggedEvent: null,
    searchQuery: '',
    linkModalSearchQuery: '',
    selectedFilter: 'all',
    collapsedSections: {},
    contentSummaryCollapsed: {},
    selectedEvents: [],
    selectedEventId: null,
    selectedEventData: null,
    autoSaveStatus: 'saved',
    eventSections: {},
    eventTypeFilters: [],
    importanceFilters: [],
    statusFilters: [],
    eventTags: {}, // Store tags for each event: { eventId: [tag1, tag2, ...] }
    loadingTags: new Set(), // Track which tags are currently being processed
    timelineTagSuggestions: [], // Available timeline tags for autocomplete

    // Tag filtering state
    showTagFilters: false,
    showFilterSection: false, // For the new dedicated filter section
    selectedTagFilters: [],
    tagFilterMode: 'filter', // 'filter' or 'highlight'

    // Sidebar visibility state (pull-out tab system)
    showLeftSidebar: false,  // Closed by default on desktop
    showRightSidebar: false,
    isDesktop: window.innerWidth >= 1024,

    // Reactive properties for real-time inspector panel updates
    liveTitle: '',
    liveTimeLabel: '',
    liveEndTimeLabel: '',
    liveDescription: '',
    activeInputListeners: new Map(), // Track active listeners for cleanup
    // Timeline form data
    timelineName: '<%= j(@timeline.name) %>',
    timelineSubtitle: '<%= j(@timeline.subtitle) %>',

    // Inline edit states
    editingTitle: false,
    editingSubtitle: false,
    tempTitle: '<%= j(@timeline.name) %>',
    tempSubtitle: '<%= j(@timeline.subtitle) %>',

    // Initialize method
    init() {
      // Initialize sidebar state
      this.initializeSidebarState();
      this.setupResizeListener();

      // Initialize eventTags from server-rendered DOM data
      this.initializeEventTagsFromDOM();

      // Load timeline tag suggestions for autocomplete
      this.loadTimelineTagSuggestions();

      // Add fallback click handlers for server-rendered events in case Alpine.js @click isn't working
      setTimeout(() => {
        const serverEventCards = document.querySelectorAll('.timeline-event-card:not(.js-template-event-card)');

        serverEventCards.forEach((card) => {
          const eventContainer = card.closest('[data-event-id]');
          if (eventContainer) {
            const eventId = parseInt(eventContainer.getAttribute('data-event-id'));

            // Add a JavaScript click listener as fallback
            card.addEventListener('click', (e) => {
              // Check if Alpine.js handler already processed this
              if (e.alpineProcessed) {
                return;
              }

              // Get event data from the card
              const titleEl = card.querySelector('input[name*="[title]"]');
              const timeEl = card.querySelector('input[name*="[time_label]"]');
              const descEl = card.querySelector('textarea[name*="[description]"]');

              const eventData = {
                id: eventId,
                title: titleEl ? titleEl.value : 'Untitled Event',
                time_label: timeEl ? timeEl.value : '',
                description: descEl ? descEl.value : '',
                event_type: 'general',
                importance_level: 'minor',
                status: 'completed',
                tags: []
              };

              this.selectEvent(eventId, eventData);
            });
          }
        });
      }, 500);
    },

    // Initialize eventTags object from server-rendered DOM
    initializeEventTagsFromDOM() {
      const eventContainers = document.querySelectorAll('.timeline-event-container:not(.timeline-event-template)');

      eventContainers.forEach(container => {
        const eventId = container.getAttribute('data-event-id');
        if (!eventId) return;

        // Find the tags container for this event
        const tagContainer = container.querySelector(`#event-tags-${eventId}`);
        if (!tagContainer) {
          this.eventTags[eventId] = [];
          return;
        }

        // Extract tag names from server-rendered spans
        const tagSpans = tagContainer.querySelectorAll('span');
        const tags = Array.from(tagSpans).map(span => span.textContent.trim());

        this.eventTags[eventId] = tags;
      });
    },

    // Load timeline tag suggestions for autocomplete
    async loadTimelineTagSuggestions() {
      try {
        const response = await fetch(`/plan/timelines/<%= @timeline.id %>/tag_suggestions`);
        const data = await response.json();
        this.timelineTagSuggestions = data.suggestions || [];
      } catch (error) {
        console.error('Failed to load timeline tag suggestions:', error);
        this.timelineTagSuggestions = [];
      }
    },

    // Filter helper methods
    clearAllFilters() {
      this.eventTypeFilters = [];
      this.importanceFilters = [];
      this.statusFilters = [];
    },

    getFilteredEventCount() {
      const events = document.querySelectorAll('.timeline-event-container:not(.timeline-event-template)');
      let count = 0;
      events.forEach(event => {
        if (this.shouldShowEvent(event)) count++;
      });
      return count;
    },

    shouldShowEvent(eventElement) {
      const eventData = this.getEventDataFromElement(eventElement);

      // Search filter
      if (this.searchQuery && !this.matchesSearch(eventData)) {
        return false;
      }

      // Tag filter - only apply in filter mode, not highlight mode
      if (this.tagFilterMode === 'filter' && this.selectedTagFilters.length > 0) {
        const eventId = eventElement.getAttribute('data-event-id');
        const eventTags = this.getEventTags(eventId);

        // Check if event has any of the selected tags
        const hasSelectedTag = this.selectedTagFilters.some(selectedTag =>
          eventTags.includes(selectedTag)
        );

        if (!hasSelectedTag) {
          return false;
        }
      }

      // Type filter
      if (this.eventTypeFilters.length > 0 && !this.eventTypeFilters.includes(eventData.type)) {
        return false;
      }

      // Importance filter
      if (this.importanceFilters.length > 0 && !this.importanceFilters.includes(eventData.importance)) {
        return false;
      }

      // Status filter
      if (this.statusFilters.length > 0 && !this.statusFilters.includes(eventData.status)) {
        return false;
      }

      return true;
    },

    getEventDataFromElement(eventElement) {
      const title = eventElement.querySelector('input[name*="[title]"]')?.value || '';
      const description = eventElement.querySelector('textarea[name*="[description]"]')?.value || '';

      // Use data attributes instead of form elements for reliable filtering
      const type = eventElement.dataset.eventType || eventElement.getAttribute('data-event-type') || 'general';
      const importance = eventElement.dataset.importance || eventElement.getAttribute('data-importance') || 'minor';
      const status = eventElement.dataset.status || eventElement.getAttribute('data-status') || 'completed';

      return {
        title: title.toLowerCase(),
        description: description.toLowerCase(),
        type: type || 'general',
        importance: importance || 'minor',
        status: status || 'completed'
      };
    },

    matchesSearch(eventData) {
      const query = this.searchQuery.toLowerCase();
      return eventData.title.includes(query) || eventData.description.includes(query);
    },

    // Apply real-time filtering to timeline events
    applyEventFilters() {
      const events = document.querySelectorAll('.timeline-event-container:not(.timeline-event-template)');
      let visibleCount = 0;

      events.forEach(eventElement => {
        const shouldShow = this.shouldShowEvent(eventElement);
        const eventId = eventElement.getAttribute('data-event-id');

        if (shouldShow) {
          eventElement.style.display = 'block';
          eventElement.style.opacity = '1';
          eventElement.style.transform = 'translateY(0)';
          visibleCount++;
        } else {
          eventElement.style.opacity = '0';
          eventElement.style.transform = 'translateY(-10px)';
          setTimeout(() => {
            if (!this.shouldShowEvent(eventElement)) {
              eventElement.style.display = 'none';
            }
          }, 200);
        }

        // Update tag display for highlight mode (only when needed)
        if (eventId && shouldShow && this.tagFilterMode === 'highlight' && this.selectedTagFilters.length > 0) {
          this.updateMainPanelTags(eventId);
        }
      });

      // Update empty state
      this.updateEmptyState(visibleCount);

      return visibleCount;
    },

    updateEmptyState(visibleCount) {
      const eventsContainer = document.querySelector('.timeline-events-container');
      let emptyState = eventsContainer.querySelector('.search-empty-state');

      if (visibleCount === 0 && this.searchQuery.length > 0) {
        // Show search empty state
        if (!emptyState) {
          emptyState = document.createElement('div');
          emptyState.className = 'search-empty-state text-center py-16';
          emptyState.innerHTML = `
            <div class="mx-auto h-16 w-16 rounded-full bg-gray-100 flex items-center justify-center mb-4">
              <i class="material-icons text-2xl text-gray-400">search_off</i>
            </div>
            <h3 class="text-lg font-medium text-gray-900 mb-2">No events found</h3>
            <p class="text-gray-600 text-sm">
              Try adjusting your search terms or clear the search to see all events.
            </p>
            <button @click="searchQuery = ''; applyEventFilters()"
                    class="mt-4 inline-flex items-center px-4 py-2 text-sm font-medium rounded-lg text-gray-700 bg-white border border-gray-300 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors">
              <i class="material-icons text-sm mr-2">clear</i>
              Clear Search
            </button>
          `;
          eventsContainer.appendChild(emptyState);
        }
        emptyState.style.display = 'block';
      } else {
        // Hide search empty state
        if (emptyState) {
          emptyState.style.display = 'none';
        }
      }
    },

    // Link modal methods
    openLinkModal(eventId) {
      this.linkingEventId = eventId;
      this.showLinkModal = true;
      this.linkModalSearchQuery = '';
      this.selectedFilter = 'all';
      this.showMobileFilters = false;
      // Focus the search input after modal opens
      setTimeout(() => {
        const searchInput = document.querySelector('.link-modal-search');
        if (searchInput) searchInput.focus();
      }, 100);
    },

    closeLinkModal() {
      this.showLinkModal = false;
      this.linkingEventId = null;
      this.linkModalSearchQuery = '';
      this.selectedFilter = 'all';
      this.showMobileFilters = false;
      this.collapsedSections = {};
    },

    toggleSection(sectionKey) {
      this.collapsedSections[sectionKey] = !this.collapsedSections[sectionKey];
    },

    isSectionCollapsed(sectionKey) {
      return this.collapsedSections[sectionKey] || false;
    },

    // Content summary section management
    toggleContentSummarySection(contentType) {
      this.contentSummaryCollapsed[contentType] = !this.contentSummaryCollapsed[contentType];
    },

    isContentSummaryCollapsed(contentType) {
      // Default to collapsed (true) on first load to handle lots of content
      return this.contentSummaryCollapsed[contentType] ?? true;
    },

    linkableContentMatches(contentName, contentType) {

      // First check filter selection
      if (this.selectedFilter && this.selectedFilter !== 'all') {
        // Special case for timeline filter
        if (this.selectedFilter === 'timeline') {
          if (contentName !== 'timeline' && contentType !== 'timeline') {
            return false;
          }
        } else {
          // Regular content type filter
          if (this.selectedFilter !== contentType.toLowerCase()) {
            return false;
          }
        }
      }

      // Then apply search query if present
      if (this.linkModalSearchQuery) {
        const query = this.linkModalSearchQuery.toLowerCase();
        return contentName.toLowerCase().includes(query);
      }

      // If no search query and filter matches (or is 'all'), show the content
      return true;
    },

    linkFirstResult() {
      const visibleButtons = document.querySelectorAll('.js-link-entity-selection');
      let firstVisibleButton = null;

      for (let button of visibleButtons) {
        if (button.offsetParent !== null && !button.style.display.includes('none')) {
          firstVisibleButton = button;
          break;
        }
      }

      if (firstVisibleButton) {
        firstVisibleButton.click();
      }
    },

    // Event section management
    toggleEventSection(eventId, section) {
      const key = `${eventId}_${section}`;
      this.eventSections[key] = !this.eventSections[key];
    },

    isEventSectionOpen(eventId, section) {
      const key = `${eventId}_${section}`;
      return this.eventSections[key] || false;
    },

    // Event selection for inspector panel
    selectEvent(eventId, eventData) {
      this.selectedEventId = eventId;
      this.selectedEventData = eventData;

      // Auto-open inspector panel when event is selected
      if (!this.showRightSidebar) {
        this.showRightSidebar = true;
        if (this.isDesktop) {
          this.saveSidebarState();
        }
      }

      // Set up live form listeners for real-time inspector panel updates
      this.setupLiveFormListeners(eventId);

      // Update sidebar linked content
      this.updateSidebarLinkedContent(eventId);

      // Load tags for this event - use provided tags or ensure they're cached
      if (eventData && eventData.tags) {
        this.eventTags[eventId] = eventData.tags;
        // Only update tag display if tags were actually provided
        if (eventData.tags.length > 0) {
          this.updateMainPanelTags(eventId);
        }
      } else {
        // getEventTags() will handle caching from DOM if needed
        this.getEventTags(eventId);
      }

      // Scroll inspector panel to top
      const inspectorContent = document.querySelector('.w-96 .overflow-y-auto');
      if (inspectorContent) {
        inspectorContent.scrollTop = 0;
      }
    },

    clearEventSelection() {
      this.selectedEventId = null;
      this.selectedEventData = null;
      this.clearInputListeners();
    },

    // Set up real-time input listeners for inspector panel updates
    setupLiveFormListeners(eventId) {
      // Clear any existing listeners first
      this.clearInputListeners();

      // Find form inputs for this event
      const eventContainer = document.querySelector(`[data-event-id="${eventId}"]`);
      if (!eventContainer) {
        return;
      }

      const titleInput = eventContainer.querySelector('input[name*="[title]"]');
      const timeLabelInput = eventContainer.querySelector('input[name*="[time_label]"]');
      const endTimeLabelInput = eventContainer.querySelector('input[name*="[end_time_label]"]');
      const descriptionTextarea = eventContainer.querySelector('textarea[name*="[description]"]');

      // Set initial values
      this.liveTitle = titleInput?.value || 'Untitled Event';
      this.liveTimeLabel = timeLabelInput?.value || '';
      this.liveEndTimeLabel = endTimeLabelInput?.value || '';
      this.liveDescription = descriptionTextarea?.value || '';

      // Create and store event listeners
      const listeners = [];

      if (titleInput) {
        const titleListener = (e) => {
          this.liveTitle = e.target.value || 'Untitled Event';
        };
        titleInput.addEventListener('input', titleListener);
        listeners.push({ element: titleInput, type: 'input', listener: titleListener });
      }

      if (timeLabelInput) {
        const timeLabelListener = (e) => {
          this.liveTimeLabel = e.target.value || '';
        };
        timeLabelInput.addEventListener('input', timeLabelListener);
        listeners.push({ element: timeLabelInput, type: 'input', listener: timeLabelListener });
      }

      if (endTimeLabelInput) {
        const endTimeLabelListener = (e) => {
          this.liveEndTimeLabel = e.target.value || '';
        };
        endTimeLabelInput.addEventListener('input', endTimeLabelListener);
        listeners.push({ element: endTimeLabelInput, type: 'input', listener: endTimeLabelListener });
      }

      if (descriptionTextarea) {
        const descriptionListener = (e) => {
          this.liveDescription = e.target.value || '';
        };
        descriptionTextarea.addEventListener('input', descriptionListener);
        listeners.push({ element: descriptionTextarea, type: 'input', listener: descriptionListener });
      }

      // Store listeners for cleanup
      this.activeInputListeners.set(eventId, listeners);
    },

    // Clear all active input listeners
    clearInputListeners() {
      this.activeInputListeners.forEach((listeners, eventId) => {
        listeners.forEach(({ element, type, listener }) => {
          element.removeEventListener(type, listener);
        });
      });

      this.activeInputListeners.clear();

      // Reset live data
      this.liveTitle = '';
      this.liveTimeLabel = '';
      this.liveEndTimeLabel = '';
      this.liveDescription = '';
    },

    // Update sidebar linked content
    updateSidebarLinkedContent(eventId) {
      const sidebarContainer = document.getElementById('sidebar-linked-content');
      if (!sidebarContainer) {
        return;
      }

      // Find the main timeline linked content for this event
      const mainLinkedContent = document.querySelector(`#linked-content-${eventId}`);
      if (!mainLinkedContent) {
        // Show empty state
        sidebarContainer.innerHTML = `
          <div class="text-xs text-gray-500 bg-gray-50 rounded-lg p-3">
            <i class="material-icons text-xs mr-1">info</i>
            Linked content will appear here when you connect pages to this event
          </div>
        `;
        return;
      }

      // Extract linked entities from the main content
      const linkedCards = mainLinkedContent.querySelectorAll('.linked-content-card');

      if (linkedCards.length === 0) {
        // Show empty state
        sidebarContainer.innerHTML = `
          <div class="text-xs text-gray-500 bg-gray-50 rounded-lg p-3">
            <i class="material-icons text-xs mr-1">info</i>
            Linked content will appear here when you connect pages to this event
          </div>
        `;
        return;
      }

      // Build compact vertical list
      let sidebarHTML = '';
      linkedCards.forEach(card => {
        const nameLink = card.querySelector('.type-badge a');
        const icon = card.querySelector('.type-badge i');
        const removeButton = card.querySelector('.remove-btn');

        if (nameLink && icon) {
          const name = nameLink.textContent.trim();
          const href = nameLink.getAttribute('href');
          const iconClass = icon.className;
          const iconText = icon.textContent;
          const removeHref = removeButton ? removeButton.getAttribute('href') : '';

          sidebarHTML += `
            <div class="flex items-center justify-between p-2 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors group">
              <div class="flex items-center min-w-0 flex-1">
                <i class="${iconClass} text-sm mr-2 flex-shrink-0">${iconText}</i>
                <a href="${href}" class="text-sm text-gray-700 hover:text-gray-900 font-medium truncate" target="_blank">
                  ${name}
                </a>
              </div>
              ${removeButton ? `
                <button onclick="unlinkFromSidebar('${removeHref}', this)"
                        class="ml-2 p-1 rounded-full text-gray-400 hover:text-red-600 hover:bg-red-50 opacity-0 group-hover:opacity-100 transition-all duration-200 flex-shrink-0"
                        title="Remove link">
                  <i class="material-icons text-xs">close</i>
                </button>
              ` : ''}
            </div>
          `;
        }
      });

      sidebarContainer.innerHTML = sidebarHTML;
    },

    // Computed properties for live form data reading (now using reactive data with DOM fallback)
    get selectedEventTitle() {
      if (!this.selectedEventId) return '';

      // Use reactive data if available (updated by input listeners)
      if (this.liveTitle) {
        return this.liveTitle;
      }

      // Fallback to DOM query for initial load
      const input = document.querySelector(`[data-event-id="${this.selectedEventId}"] input[name*="[title]"]`);
      return input?.value || 'Untitled Event';
    },

    get selectedEventTimeLabel() {
      if (!this.selectedEventId) return '';

      // Use reactive data if available (updated by input listeners)
      if (this.liveTimeLabel !== '') {
        return this.liveTimeLabel;
      }

      // Fallback to DOM query for initial load
      const input = document.querySelector(`[data-event-id="${this.selectedEventId}"] input[name*="[time_label]"]`);
      return input?.value || '';
    },

    get selectedEventEndTimeLabel() {
      if (!this.selectedEventId) return '';

      // Use reactive data if available (updated by input listeners)
      if (this.liveEndTimeLabel !== '') {
        return this.liveEndTimeLabel;
      }

      // Fallback to DOM query for initial load
      const input = document.querySelector(`[data-event-id="${this.selectedEventId}"] input[name*="[end_time_label]"]`);
      return input?.value || '';
    },

    get selectedEventDescription() {
      if (!this.selectedEventId) return '';

      // Use reactive data if available (updated by input listeners)
      if (this.liveDescription !== '') {
        return this.liveDescription;
      }

      // Fallback to DOM query for initial load
      const textarea = document.querySelector(`[data-event-id="${this.selectedEventId}"] textarea[name*="[description]"]`);
      return textarea?.value || '';
    },

    get selectedEventType() {
      if (!this.selectedEventId) return 'general';
      return this.selectedEventData?.event_type || 'general';
    },

    // Event type helper methods
    getEventTypeIcon(eventId) {
      if (!eventId) return 'radio_button_checked';
      const eventType = this.selectedEventData?.event_type || 'general';
      const eventTypeMap = {
        'general': 'radio_button_checked',
        'setup': 'foundation',
        'exposition': 'info',
        'inciting_incident': 'flash_on',
        'complication': 'warning',
        'obstacle': 'block',
        'conflict': 'gavel',
        'progress': 'trending_up',
        'revelation': 'visibility',
        'transformation': 'autorenew',
        'climax': 'whatshot',
        'resolution': 'check_circle',
        'aftermath': 'restore'
      };
      return eventTypeMap[eventType] || 'radio_button_checked';
    },

    getEventTypeName(eventId) {
      if (!eventId) return 'General';
      const eventType = this.selectedEventData?.event_type || 'general';
      const eventTypeMap = {
        'general': 'General',
        'setup': 'Setup',
        'exposition': 'Exposition',
        'inciting_incident': 'Inciting Incident',
        'complication': 'Complication',
        'obstacle': 'Obstacle',
        'conflict': 'Conflict',
        'progress': 'Progress',
        'revelation': 'Revelation',
        'transformation': 'Transformation',
        'climax': 'Climax',
        'resolution': 'Resolution',
        'aftermath': 'Aftermath'
      };
      return eventTypeMap[eventType] || 'General';
    },

    // Update event type and refresh timeline dot
    updateEventType(newType) {
      if (!this.selectedEventId) return;

      // Update the selected event data
      if (this.selectedEventData) {
        this.selectedEventData.event_type = newType;
      }

      // Find the event form and submit the update
      const eventContainer = document.querySelector(`[data-event-id="${this.selectedEventId}"]`);
      if (eventContainer) {
        // Create a form to submit the event type update
        const form = document.createElement('form');
        form.setAttribute('method', 'POST');
        form.setAttribute('action', `/plan/timeline_events/${this.selectedEventId}`);
        form.classList.add('autosave-form');

        // Add CSRF token
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
        if (csrfToken) {
          const csrfInput = document.createElement('input');
          csrfInput.type = 'hidden';
          csrfInput.name = 'authenticity_token';
          csrfInput.value = csrfToken;
          form.appendChild(csrfInput);
        }

        // Add method override
        const methodInput = document.createElement('input');
        methodInput.type = 'hidden';
        methodInput.name = '_method';
        methodInput.value = 'patch';
        form.appendChild(methodInput);

        // Add event type
        const eventTypeInput = document.createElement('input');
        eventTypeInput.type = 'hidden';
        eventTypeInput.name = 'timeline_event[event_type]';
        eventTypeInput.value = newType;
        form.appendChild(eventTypeInput);

        // Submit via our existing auto-save mechanism
        submitFormWithFetch(form);

        // Update the timeline dot icon and tooltip immediately
        const timelineDotContainer = eventContainer.querySelector('.timeline-dot');
        const timelineDot = timelineDotContainer?.querySelector('i');
        if (timelineDot && timelineDotContainer) {
          const iconMap = {
            'general': 'radio_button_checked',
            'setup': 'foundation',
            'exposition': 'info',
            'inciting_incident': 'flash_on',
            'complication': 'warning',
            'obstacle': 'block',
            'conflict': 'gavel',
            'progress': 'trending_up',
            'revelation': 'visibility',
            'transformation': 'autorenew',
            'climax': 'whatshot',
            'resolution': 'check_circle',
            'aftermath': 'restore'
          };
          const nameMap = {
            'general': 'General',
            'setup': 'Setup',
            'exposition': 'Exposition',
            'inciting_incident': 'Inciting Incident',
            'complication': 'Complication',
            'obstacle': 'Obstacle',
            'conflict': 'Conflict',
            'progress': 'Progress',
            'revelation': 'Revelation',
            'transformation': 'Transformation',
            'climax': 'Climax',
            'resolution': 'Resolution',
            'aftermath': 'Aftermath'
          };
          timelineDot.textContent = iconMap[newType] || 'radio_button_checked';
          timelineDotContainer.title = nameMap[newType] || 'General';
        }
      }
    },

    // Tag management methods
    getEventTags(eventId) {
      if (!eventId) return [];

      // If we have cached tags, return them
      if (this.eventTags[eventId]) {
        return this.eventTags[eventId];
      }

      // Fallback: scrape tags from DOM if not in cache
      const tagContainer = document.querySelector(`#event-tags-${eventId}`);
      if (!tagContainer) {
        this.eventTags[eventId] = [];
        return [];
      }

      const tagSpans = tagContainer.querySelectorAll('span');
      const tags = Array.from(tagSpans).map(span => span.textContent.trim());

      // Cache the scraped tags
      this.eventTags[eventId] = tags;
      return tags;
    },

    loadEventTags(eventId) {
      if (!eventId) return;

      // Find the event's existing tags from the server-rendered data
      const eventContainer = document.querySelector(`[data-event-id="${eventId}"]`);
      if (!eventContainer) {
        this.eventTags[eventId] = [];
        return;
      }

      // For now, initialize empty array - in future could fetch from API
      // The tags will be loaded when the page renders with existing data
      this.eventTags[eventId] = [];
    },

    addEventTag(tagName) {
      if (!this.selectedEventId || !tagName.trim()) return;

      const cleanTagName = tagName.trim();

      // Check if tag already exists
      const existingTags = this.getEventTags(this.selectedEventId);
      if (existingTags.includes(cleanTagName)) {
        return; // Tag already exists
      }

      // Optimistically add tag to local state immediately
      if (!this.eventTags[this.selectedEventId]) {
        this.eventTags[this.selectedEventId] = [];
      }
      this.eventTags[this.selectedEventId].push(cleanTagName);

      // Clear tag container cache for this event
      if (this._tagContainerCache) {
        this._tagContainerCache.delete(this.selectedEventId);
      }

      // Update the main panel tag display
      this.updateMainPanelTags(this.selectedEventId);

      // Mark this tag as loading
      this.loadingTags.add(`${this.selectedEventId}-${cleanTagName}`);

      // Set loading state
      this.autoSaveStatus = 'saving';

      // Make API call to add tag
      fetch(`/plan/timeline_events/${this.selectedEventId}/tags`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          tag_name: cleanTagName
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.status === 'success') {
          // Remove loading state for this tag
          this.loadingTags.delete(`${this.selectedEventId}-${cleanTagName}`);

          // Tag was already added optimistically, just update save status
          this.autoSaveStatus = 'saved';
          setTimeout(() => {
            if (this.autoSaveStatus === 'saved') {
              this.autoSaveStatus = 'saved'; // Keep it visible for a moment
            }
          }, 1000);
        } else {
          throw new Error(data.message || 'Failed to add tag');
        }
      })
      .catch(error => {
        console.error('Error adding tag:', error);
        this.autoSaveStatus = 'error';

        // Remove loading state for this tag
        this.loadingTags.delete(`${this.selectedEventId}-${cleanTagName}`);

        // Remove the optimistically added tag since the request failed
        if (this.eventTags[this.selectedEventId]) {
          this.eventTags[this.selectedEventId] = this.eventTags[this.selectedEventId].filter(tag => tag !== cleanTagName);
        }

        // Clear tag container cache for this event
        if (this._tagContainerCache) {
          this._tagContainerCache.delete(this.selectedEventId);
        }

        // Update the main panel tag display
        this.updateMainPanelTags(this.selectedEventId);

        // Show error for a few seconds, then revert
        setTimeout(() => {
          if (this.autoSaveStatus === 'error') {
            this.autoSaveStatus = 'saved';
          }
        }, 3000);
      });
    },

    removeEventTag(tagName) {
      if (!this.selectedEventId || !tagName) return;

      // Store the original tags for rollback if needed
      const originalTags = [...(this.eventTags[this.selectedEventId] || [])];

      // Mark this tag as loading before removal
      this.loadingTags.add(`${this.selectedEventId}-${tagName}`);

      // Optimistically remove tag from local state immediately
      if (this.eventTags[this.selectedEventId]) {
        this.eventTags[this.selectedEventId] = this.eventTags[this.selectedEventId].filter(tag => tag !== tagName);
      }

      // Clear tag container cache for this event
      if (this._tagContainerCache) {
        this._tagContainerCache.delete(this.selectedEventId);
      }

      // Update the main panel tag display
      this.updateMainPanelTags(this.selectedEventId);

      // Set loading state
      this.autoSaveStatus = 'saving';

      // Make API call to remove tag
      fetch(`/plan/timeline_events/${this.selectedEventId}/tags/${encodeURIComponent(tagName)}`, {
        method: 'DELETE',
        headers: {
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
          'Accept': 'application/json'
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.status === 'success') {
          // Remove loading state for this tag
          this.loadingTags.delete(`${this.selectedEventId}-${tagName}`);

          // Tag was already removed optimistically, just update save status
          this.autoSaveStatus = 'saved';
          setTimeout(() => {
            if (this.autoSaveStatus === 'saved') {
              this.autoSaveStatus = 'saved'; // Keep it visible for a moment
            }
          }, 1000);
        } else {
          throw new Error(data.message || 'Failed to remove tag');
        }
      })
      .catch(error => {
        console.error('Error removing tag:', error);
        this.autoSaveStatus = 'error';

        // Remove loading state for this tag
        this.loadingTags.delete(`${this.selectedEventId}-${tagName}`);

        // Restore the original tags since the request failed
        this.eventTags[this.selectedEventId] = originalTags;

        // Clear tag container cache for this event
        if (this._tagContainerCache) {
          this._tagContainerCache.delete(this.selectedEventId);
        }

        // Update the main panel tag display
        this.updateMainPanelTags(this.selectedEventId);

        // Show error for a few seconds, then revert
        setTimeout(() => {
          if (this.autoSaveStatus === 'error') {
            this.autoSaveStatus = 'saved';
          }
        }, 3000);
      });
    },

    // Helper method to check if a tag is currently loading
    isTagLoading(eventId, tagName) {
      return this.loadingTags.has(`${eventId}-${tagName}`);
    },

    // Update the main panel tag display for an event
    updateMainPanelTags(eventId) {
      // Cache DOM query
      if (!this._tagContainerCache) {
        this._tagContainerCache = new Map();
      }

      let tagContainer = this._tagContainerCache.get(eventId);
      if (!tagContainer) {
        tagContainer = document.querySelector(`#event-tags-${eventId}`);
        if (!tagContainer) return;
        this._tagContainerCache.set(eventId, tagContainer);
      }

      const eventTags = this.getEventTags(eventId);

      if (eventTags.length === 0) {
        // Batch DOM updates
        if (!tagContainer.classList.contains('hidden')) {
          tagContainer.classList.add('hidden');
          tagContainer.innerHTML = '';
        }
      } else {
        // Check if we need to update highlighting
        const needsHighlightUpdate = this.tagFilterMode === 'highlight' && this.selectedTagFilters.length > 0;
        const currentContent = tagContainer.innerHTML;

        const newContent = eventTags.map(tag => {
          const isHighlighted = needsHighlightUpdate && this.selectedTagFilters.includes(tag);
          return `
            <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium transition-colors ${
              isHighlighted
                ? 'bg-yellow-200 text-yellow-800 border border-yellow-300'
                : 'bg-gray-100 text-gray-600 border border-gray-200'
            }">
              ${tag}
            </span>
          `;
        }).join('');

        // Only update DOM if content actually changed
        if (currentContent !== newContent) {
          tagContainer.classList.remove('hidden');
          tagContainer.innerHTML = newContent;
        }
      }
    },

    // Clear all tag filters
    clearTagFilters() {
      this.selectedTagFilters = [];
      this.applyEventFilters();

      // Only update tag displays if we were in highlight mode
      if (this.tagFilterMode === 'highlight') {
        Object.keys(this.eventTags).forEach(eventId => {
          this.updateMainPanelTags(eventId);
        });
      }
    },

    // Handle tag filter mode change
    changeTagFilterMode(newMode) {
      this.tagFilterMode = newMode;
      this.applyEventFilters();
    },

    // Sidebar toggle methods (pull-out tab system)
    toggleLeftSidebar() {
      this.showLeftSidebar = !this.showLeftSidebar;
    },

    toggleRightSidebar() {
      this.showRightSidebar = !this.showRightSidebar;
      if (this.isDesktop) {
        this.saveSidebarState();
      }
    },

    initializeSidebarState() {
      if (this.isDesktop) {
        this.showRightSidebar = this.getSavedSidebarState();
      } else {
        this.showRightSidebar = false;
      }
    },

    setupResizeListener() {
      window.addEventListener('resize', () => {
        const wasDesktop = this.isDesktop;
        this.isDesktop = window.innerWidth >= 1024;

        // When transitioning from mobile to desktop, restore saved state
        if (!wasDesktop && this.isDesktop) {
          this.showRightSidebar = this.getSavedSidebarState();
        }
        // When transitioning from desktop to mobile, close sidebars
        if (wasDesktop && !this.isDesktop) {
          this.showLeftSidebar = false;
          this.showRightSidebar = false;
        }
      });
    },

    getSavedSidebarState() {
      try {
        const saved = localStorage.getItem('timeline_edit_right_sidebar_visible');
        return saved === 'true';
      } catch (e) {
        return false;
      }
    },

    saveSidebarState() {
      try {
        localStorage.setItem('timeline_edit_right_sidebar_visible', this.showRightSidebar.toString());
      } catch (e) {
        // Silently fail if localStorage is unavailable
      }
    },

    closeMobileSidebar() {
      if (!this.isDesktop) {
        this.showRightSidebar = false;
      }
    },

    closeMobileLeftSidebar() {
      if (!this.isDesktop) {
        this.showLeftSidebar = false;
      }
    },

    // Inline edit methods
    saveTitle() {
      this.timelineName = this.tempTitle;
      const form = document.querySelector('[x-ref="titleForm"]');
      if (form) {
        const input = form.querySelector('input[name="timeline[name]"]');
        if (input) {
          input.value = this.tempTitle;
        }
        this.editingTitle = false;
        submitFormWithFetch(form);
      }
    },

    saveSubtitle() {
      this.timelineSubtitle = this.tempSubtitle;
      const form = document.querySelector('[x-ref="subtitleForm"]');
      if (form) {
        const input = form.querySelector('input[name="timeline[subtitle]"]');
        if (input) {
          input.value = this.tempSubtitle;
        }
        this.editingSubtitle = false;
        submitFormWithFetch(form);
      }
    }
  };
}


// Global function for updating timeline tags
function updateTimelineTags(timelineId, tags) {
  const tagString = tags.join(',,,|||,,,');
  console.log('Sending tags:', tagString, 'from array:', tags);

  // Create a temporary form to submit the tag update
  const form = document.createElement('form');
  form.method = 'POST';
  form.action = `/plan/timelines/${timelineId}`;
  form.style.display = 'none';

  // Add CSRF token
  const csrfInput = document.createElement('input');
  csrfInput.type = 'hidden';
  csrfInput.name = 'authenticity_token';
  csrfInput.value = document.querySelector('meta[name=csrf-token]').content;
  form.appendChild(csrfInput);

  // Add method override for PATCH
  const methodInput = document.createElement('input');
  methodInput.type = 'hidden';
  methodInput.name = '_method';
  methodInput.value = 'patch';
  form.appendChild(methodInput);

  // Add tags field - send all current tags
  const tagsInput = document.createElement('input');
  tagsInput.type = 'hidden';
  tagsInput.name = 'timeline[page_tags]';
  tagsInput.value = tagString;
  form.appendChild(tagsInput);

  // Submit form
  document.body.appendChild(form);
  return fetch(form.action, {
    method: 'PATCH',
    body: new FormData(form),
    headers: {
      'X-CSRF-Token': csrfInput.value,
      'Accept': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    }
  })
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  })
  .then(data => {
    console.log('Tags update successful:', data);
    // Set status to indicate successful save
    const alpineEl = document.querySelector('[x-data*="timelineEditor"]');
    if (alpineEl && window.Alpine) {
      Alpine.$data(alpineEl).autoSaveStatus = 'saved';
      setTimeout(() => {
        if (Alpine.$data(alpineEl).autoSaveStatus === 'saved') {
          Alpine.$data(alpineEl).autoSaveStatus = 'saved';
        }
      }, 2000);
    }
  })
  .catch(error => {
    console.error('Error updating tags:', error);
    // Revert to server state on error by reloading
    location.reload();
  })
  .finally(() => {
    document.body.removeChild(form);
  });
}

// Helper function to submit forms remotely
function submitFormRemotely(form) {

  if (form.getAttribute('data-remote') !== 'true') {
    form.setAttribute('data-remote', 'true');
  }


  // Use Rails UJS to submit the form remotely
  if (typeof Rails !== 'undefined' && Rails.fire) {
    Rails.fire(form, 'submit');
  } else {
    // Manual AJAX implementation since Rails UJS is not working
    submitFormWithFetch(form);
  }
}

// Manual AJAX form submission function
function submitFormWithFetch(form) {

  // Set auto-save status to saving
  const alpineEl = document.querySelector('[x-data]');
  if (alpineEl) {
    Alpine.$data(alpineEl).autoSaveStatus = 'saving';
  }

  const formData = new FormData(form);
  const url = form.action;
  const method = form.method.toUpperCase();

  // Add Rails authenticity token if not present
  const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
  if (csrfToken && !formData.has('authenticity_token')) {
    formData.append('authenticity_token', csrfToken);
  }


  fetch(url, {
    method: method,
    body: formData,
    headers: {
      'X-CSRF-Token': csrfToken,
      'Accept': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    }
  })
  .then(response => {
    if (response.ok) {
      return response.json();
    } else {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
  })
  .then(data => {

    // Trigger success event manually
    const successEvent = new CustomEvent('ajax:success', {
      detail: [data],
      bubbles: true,
      cancelable: true
    });
    form.dispatchEvent(successEvent);

    // Update auto-save status
    if (alpineEl) {
      Alpine.$data(alpineEl).autoSaveStatus = 'saved';
      setTimeout(() => {
        Alpine.$data(alpineEl).autoSaveStatus = 'saved';
      }, 2000);
    }
  })
  .catch(error => {

    // Trigger error event manually
    const errorEvent = new CustomEvent('ajax:error', {
      detail: [null, { status: 'error', message: error.message }],
      bubbles: true,
      cancelable: true
    });
    form.dispatchEvent(errorEvent);

    // Update auto-save status
    if (alpineEl) {
      Alpine.$data(alpineEl).autoSaveStatus = 'error';
    }
  });
}
</script>
